import request from 'superagent'
import Pbf from 'pbf'
import geobuf from 'geobuf'
import L from 'leaflet'

import VectorField from './VectorField'
import ValueField from './ValueField'

const DOT_SIZE = 20
const DOT_DENSITY = 5

/**
 * A canvas tile layer which renders data from a gfs-weather-server instance.
 * Required options are:
 *  - **baseUrl** the base api url of the weather server
 *  - **type** the name of the layer to query
 *  - **surface** the surface name as given in the gfs inventory
 *  - **date** the initial (starting) date.
 *   **forecast** the initial forecast offset in hours
 * @type {L.GridLayer}
 */
export default L.GridLayer.extend({
  initialize (options) {
    L.setOptions(this, options)
  },

  /**
   * Creates a canvas tile and waits for the data from the weather server before
   * rendering to the canvas.
   */
  createTile (coords, done) {
    // const key = this._tileCoordsToKey(coords)
    // console.time(`${key} total`)
    const tile = L.DomUtil.create('canvas', 'leaflet-tile')
    const { colorScale } = this.options
    const ctx = tile.getContext('2d')
    const size = this.getTileSize()
    const map = this._map

    tile.width = size.x
    tile.height = size.y

    const nw = coords.scaleBy(size)
    const se = nw.add(size)
    // const colorMap = {}

    // console.time(`${key} load`)
    this.loadData(coords, (err, data) => {
      if (err) return console.error(err)
      // console.timeEnd(`${key} load`)

      // console.time(`${key} render total`)
      // console.time(`${key} colormap`)
      for (let y = nw.y - DOT_SIZE; y < se.y + DOT_SIZE; y += DOT_DENSITY) {
        for (let x = nw.x - DOT_SIZE; x < se.x + DOT_SIZE; x += DOT_DENSITY) {
          const latlng = map.unproject([x, y], coords.z)
          const value = data.get([latlng.lat, latlng.lng])

          const colorValues = colorScale.getColor(value)
          if (colorValues !== null) {
            const [r, g, b] = colorValues
            const color = `rgba(${r}, ${g}, ${b}, 0.02)`
            const point = [x - nw.x, y - nw.y]

            ctx.fillStyle = color
            ctx.beginPath()
            ctx.arc(
              point[0] + Math.random() * 3,
              point[1] + Math.random() * 3,
              DOT_SIZE,
              0,
              Math.PI * 2
            )
            ctx.closePath()
            ctx.fill()

            // if (!colorMap[color]) {
            //   colorMap[color] = []
            // }
            //
            // colorMap[color].push([x - nw.x, y - nw.y])
          }
        }
      }
      // console.timeEnd(`${key} colormap`)

      // console.time(`${key} render`)
      // Object.keys(colorMap).forEach((color) => {
      //   const points = colorMap[color]
      //   ctx.fillStyle = color
      //   points.forEach((point) => {
      //     ctx.beginPath()
      //     ctx.arc(point[0] + Math.random() * 3, point[1] + Math.random() * 3, DOT_SIZE, 0, Math.PI * 2)
      //     ctx.closePath()
      //     ctx.fill()
      //   })
      // })
      // console.timeEnd(`${key} render`)
      // console.timeEnd(`${key} render total`)

      // ctx.fillStyle = `rgba(${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, 1)`
      // data.forEach(([lat, lng]) => {
      //   const point = map.project([lat, lng], coords.z)
      //   ctx.beginPath()
      //   ctx.arc(point.x - nw.x, point.y - nw.y, 5, 0, Math.PI * 2)
      //   ctx.closePath()
      //   ctx.fill()
      // })

      done(null, tile)
      // console.timeEnd(`${key} total`)
    })

    return tile
  },

  /**
   * Loads data for a given tile.
   */
  loadData (tile, cb) {
    // const letkey = this._tileCoordsToKey(tile)
    // console.log(`tile ${tile.x}:${tile.y}@${tile.z}`)

    const map = this._map
    const size = this.getTileSize()
    let nwPx = tile.scaleBy(size)
    let sePx = nwPx.add(size)

    // console.log(`px bounds ${nwPx.x}:${nwPx.y} - ${sePx.x}:${sePx.y}`)

    nwPx = nwPx.subtract([DOT_SIZE, DOT_SIZE])
    sePx = sePx.add([DOT_SIZE, DOT_SIZE])

    // console.log(`px bounds ${nwPx.x}:${nwPx.y} - ${sePx.x}:${sePx.y}`)
    // nwPx.subtract([DOT_SIZE * 2, DOT_SIZE * 2])
    // sePx.add([DOT_SIZE * 4, DOT_SIZE * 4])

    const nw = map.unproject(nwPx, tile.z)
    const se = map.unproject(sePx, tile.z)

    // console.log(`geo bounds ${nw.lng}:${nw.lat} - ${se.lng}:${se.lat}`)

    const resolution = Math.max(1, (6 - tile.z) * 2)
    const nwLat = nw.lat + resolution - nw.lat % resolution
    let nwLng = nw.lng - resolution - nw.lng % resolution
    const seLat = se.lat - resolution - se.lat % resolution
    let seLng = se.lng + resolution - se.lng % resolution

    if (Math.abs(seLng - nwLng) >= 360) {
      nwLng = -180
      seLng = 180 - resolution
    }

    const bounds = [nwLng, Math.min(90, nwLat), seLng, Math.max(-90, seLat)]

    // console.log('bounds', bounds)
    const time = this.getCurrentDate().getTime()
    // console.time(`${key} io`)
    request
      .get(`${this.options.baseUrl}/layer/${this.options.type}/${time}`)
      .query({ bb: bounds.join(','), sf: resolution })
      .responseType('arraybuffer')
      .end((err, res) => {
        if (err) return cb(err)
        // console.timeEnd(`${key} io`)
        // console.time(`${key} parse`)

        const buf = parseXProtobuf(res)
        if (!buf || !buf.buf || !buf.buf.length) return
        const points = geobuf.decode(buf)
        const grid = points.features.shift()
        const { dx, dy, bounds } = grid.properties
        let field
        // console.timeEnd(`${key} parse`)

        // console.log(`${nw.lng}:${nw.lat} - ${se.lng}:${se.lat}`)

        // console.time(`${key} parse=>prepare`)
        if (this.options.type === 'uvgrd') {
          field = new VectorField(bounds, dx, dy, points.features)
        } else {
          field = new ValueField(bounds, dx, dy, points.features)
        }
        // console.timeEnd(`${key} parse=>prepare`)

        // console.log(field)

        cb(null, field)
      })
  },

  /**
   * Returns the currently displayed date (base date + forecast offset).
   */
  getCurrentDate () {
    return new Date(this.options.date.getTime() + this.options.forecast * 3600000)
  },

  /**
   * Changes the forecast offset, will cause a redraw of all tiles.
   */
  setForecast (hour) {
    this.options.forecast = hour
    if (this._map) this.redraw()
  }
})

function parseXProtobuf (res) {
  if (res.headers['content-type'] === 'application/x-protobuf') {
    return new Pbf(res.body)
  }
}
